# [odata-connection]
# Basis-URL van het OData endpoint (bijv.: https://example.com/odata.svc/)
ODATA_URL = 
# Authenticatie-modus (één van: NONE | BASIC | BEARER | HELLOME)
# HELLOME: Dynamisch token ophalen via HelloMe identity provider
ODATA_AUTH_MODE = NONE
ODATA_USERNAME = 
ODATA_PASSWORD = 
ODATA_BEARER_TOKEN = 
# Optionele HTTP-headers in JSON-formaat, bijv. {"X-CSRF-Token":"Fetch"}
ODATA_HEADERS =         
ODATA_VERIFY_SSL = true
# (Optioneel) Pad naar een custom CA-certificaatbundel (.pem) voor SSL-verificatie
# Gebruik dit als de server een self-signed certificaat of interne CA gebruikt
# Voorbeeld: ODATA_SSL_CA_CERT = C:\certs\ca_bundle.pem
ODATA_SSL_CA_CERT = 

# --- OData Protocol Versie ---
# OData versie: "2" of "4". Standaard: auto-detectie via $metadata endpoint.
# OData v2: Gebruikt pyodata library
# OData v4: Gebruikt ingebouwde ODataV4Client (directe HTTP calls met requests)
# Laat leeg voor automatische detectie op basis van $metadata response headers/namespaces.
# ODATA_VERSION = 4

# --- Client Certificate (mTLS/PKIO) ---
# Voor toegang tot de OData API-endpoint van (bijv.) het Centric Dataplatform is een geldig PKIO-certificaat vereist.
#
# OPTIE 1: .pfx/.p12 bestand (AANBEVOLEN - bevat certificaat + key in één bestand)
# Het .pfx-bestand wordt automatisch uitgepakt; wachtwoord via ODATA_CLIENT_KEY_PASSWORD
# Voorbeeld: ODATA_CLIENT_PFX = C:\certs\pkio_client.pfx
ODATA_CLIENT_PFX = 
#
# OPTIE 2: Aparte .pem/.crt bestanden
# Pad naar het client-certificaat (.pem of .crt) voor mTLS/PKIO authenticatie
# Voorbeeld: ODATA_CLIENT_CERT = C:\certs\pkio_client.pem
ODATA_CLIENT_CERT = 
# Pad naar de private key van het client-certificaat (.pem of .key)
# Als het certificaat en de key in één bestand zitten, vul alleen ODATA_CLIENT_CERT in
# Voorbeeld: ODATA_CLIENT_KEY = C:\certs\pkio_client_key.pem
ODATA_CLIENT_KEY = 
#
# Wachtwoord voor het .pfx-bestand of versleutelde private key
# LET OP: Bewaar dit wachtwoord veilig; bij .env wordt dit automatisch uit de environment geladen
ODATA_CLIENT_KEY_PASSWORD = 

# [hellome-auth]
# Instellingen voor HelloMe OAuth2 authenticatie (alleen nodig als ODATA_AUTH_MODE = HELLOME)
# Token endpoint URL, bijv.: https://<tenantcode>.hellome.center/runtime/oauth2/token.idp
HELLOME_TOKEN_ENDPOINT = 
# OAuth2 client credentials (worden verstrekt door Centric tijdens onboarding)
HELLOME_CLIENT_ID = 
HELLOME_CLIENT_SECRET = 
# Gebruikersnaam en wachtwoord voor resource owner password grant
HELLOME_USERNAME = 
HELLOME_PASSWORD = 
# (Optioneel) Aantal seconden voor verlopen token om proactief te refreshen (default: 300 = 5 min)
HELLOME_REFRESH_MARGIN_SECONDS = 300
# (Optioneel) SSL-verificatie voor HelloMe endpoint (default: gebruikt ODATA_VERIFY_SSL)
# Zet op false om SSL-verificatie uit te schakelen (niet aanbevolen voor productie)
HELLOME_VERIFY_SSL = 
# (Optioneel) Pad naar een custom CA-certificaatbundel (.pem) voor SSL-verificatie van HelloMe endpoint
# Gebruik dit als de HelloMe server een self-signed certificaat of interne CA gebruikt
# Als niet ingesteld, wordt ODATA_SSL_CA_CERT / ODATA_VERIFY_SSL gebruikt
# Voorbeeld: HELLOME_SSL_CA_CERT = C:\certs\hellome_ca.pem
HELLOME_SSL_CA_CERT =


# [odata-export]
# Comma-separated lijst van OData EntitySets om te exporteren, bijv.: Employees,Orders
# Gebruik '*' om automatisch ALLE beschikbare EntitySets te exporteren
# (Dit worden de tabellen die worden geüpload in '[database-destination]')
ODATA_ENTITY_SETS = 

# Optionele per-entity-set instellingen (gebruik de exacte naam van de entity-set):
# ODATA_SELECT_Employees = EmployeeID,LastName
# ODATA_FILTER_Employees = Active eq true
# ODATA_EXPAND_Employees = Orders

# Bepaal hoe null-waarden worden behandeld in pyodata (beïnvloedt de export)
# Bij true: null-waarden worden behouden; bij false: null-waarden worden op default-waarde ingesteld,
# waarbij verschil tussen missing/niet-missing verloren gaat
ODATA_RETAIN_NULL = true

# [odata-network]
# Netwerkinstellingen voor OData (robuustheid)
# Standaard-timeout voor HTTP-aanroepen in seconden
ODATA_REQUEST_TIMEOUT_SECONDS = 30.0
# Aantal retries bij tijdelijke fouten (429/5xx)
ODATA_MAX_RETRIES = 3
# Backoff-factor tussen retries in seconden
ODATA_RETRY_BACKOFF_SECONDS = 1.0
# Welke HTTP-statuscodes tot retry leiden (comma-separated)
ODATA_RETRY_STATUS_FORCELIST = 429,500,502,503,504
# Aantal rijen dat in één OData-aanroep wordt opgehaald
ODATA_PAGE_SIZE = 5000 

# [database-destination]
# De database waarin de OData-gegevens worden geladen
DST_DRIVER = mssql+pyodbc
DST_HOST = localhost
DST_PORT = 1433
DST_DB = staging
DST_SCHEMA = staging
DST_USERNAME = sa
DST_PASSWORD = YourStrong!Passw0rd
DST_MSSQL_ODBC_DRIVER = ODBC Driver 18 for SQL Server
# Optioneel (alleen voor Microsoft SQL Server via pyodbc): schakel TrustServerCertificate in/uit"
# Standaard: True (ontwikkelvriendelijk; certificaatketen wordt niet gevalideerd)."
# Zet op False in productie om volledige SSL-certificaatvalidatie af te dwingen."
DST_MSSQL_TRUST_SERVER_CERTIFICATE = True
# Optionele admin DB override voor automatisch aanmaken van DB (MSSQL/Postgres)
# DST_ADMIN_DB = master
# (Optioneel) Wanneer je met een OracleDB schrijft kan thick‑mode nodig zijn.
# Zet hier het pad naar de Oracle Instant Client (bijv. "C:\\oracle\\instantclient_21_18").
DST_ORACLE_CLIENT_PATH =
# (Optioneel) Als je naar een OracleDB schrijft met een TNS‑alias, zet dit op True en geef de alias
# op via 'DST_HOST' (of 'DST_DB'). Let op, als je een TNS‑alias gebruikt, worden DST_HOST en DST_PORT genegeerd
DST_ORACLE_TNS_ALIAS = False

# [settings]
# Rij-limiet per entity-set (voor ontwikkelen/testen)
ROW_LIMIT =   
# Schrijfmodus (één van: replace | truncate | append)    
WRITE_MODE = replace
# Of tijdelijke Parquet-bestanden moeten worden verwijderd na upload
CLEANUP_PARQUET_FILES = true
# Of het aantal verwerkte rijen moet worden gelogd
LOG_ROW_COUNT = true
# Of wachtwoord moet worden gevraagd in command line in plaats van config-bestand
ASK_PASSWORD_IN_CLI = false
# (Optioneel) Normaliseer tabelnamen in staging naar lower-case (aanbevolen)
LOWER_TABLE_NAMES = true

# [logging]
# Globale logging-niveau; vanaf welk type message moet gelogd worden?
# Kan zijn: DEBUG, INFO, WARNING, of ERROR
LOG_LEVEL = INFO
# Of logs in een logbestand moeten worden opgeslagen
LOG_TO_FILE = True
# Locatie van het logbestand (wordt aangemaakt indien deze nog niet bestaat)
LOG_FILE = logs/odata_to_staging.log
# Max. grootte (in bytes) van het logbestand voordat er een nieuw bestand wordt gestart (rotatie). Voorbeeld: 5.000.000 ≈ 5 MB
LOG_ROTATE_BYTES = 5000000
# Aantal oude logbestanden dat bewaard blijft bij rotatie (bijv. app.log.1 t/m app.log.N)
LOG_BACKUP_COUNT = 3
# Optioneel: eigen opmaak van logregels. Laat weg voor standaard; voorbeeld toont tijd, level, logger en bericht
# LOG_FORMAT = %(asctime)s %(levelname)-8s [%(name)s] %(message)s
