# Dit is een voorbeeld van een .ini-configuratiebestand voor de 'sql_to_staging' module
# Kopieer dit bestand naar '.ini' en pas de waarden aan naar jouw omgeving
# (.ini-bestanden moet je in de commandline meegeven bij het runnen van deze module; zie README.md)

[database-source]
SRC_DRIVER = oracle+oracledb
SRC_HOST = localhost
SRC_PORT = 1521
SRC_USERNAME = sa
SRC_PASSWORD = SecureP@ss1!24323482349
SRC_DB = ggm
SRC_SCHEMA = 
# (Optioneel) Wanneer je met een OracleDB werkt kan thick‑mode nodig zijn.
# Zet hier het pad naar de Oracle Instant Client (bijv. "C:\\oracle\\instantclient_21_18").
SRC_ORACLE_CLIENT_PATH =
# (Optioneel) Gebruik je een Oracle TNS‑alias? Zet dan op True en geef de alias op via SRC_HOST of SRC_DB
# Let op, als je een TNS‑alias gebruikt, worden SRC_HOST en SRC_PORT genegeerd
SRC_ORACLE_TNS_ALIAS = False
# Optioneel (alleen voor Microsoft SQL Server via pyodbc): kies de ODBC-driver
# Mogelijke waarden: "ODBC Driver 18 for SQL Server", "ODBC Driver 17 for SQL Server", "SQL Server"
# Laat leeg om standaard (18) te gebruiken
SRC_MSSQL_ODBC_DRIVER = 

[database-destination]
DST_DRIVER = postgresql+psycopg2
DST_HOST = localhost
DST_PORT = 5432
DST_USERNAME = sa
DST_PASSWORD = SecureP@ss1!24323482349
DST_DB = ggm
DST_SCHEMA = ggm
# (Optioneel) Override voor de admin-database die gebruikt wordt om een nieuwe database aan te maken
# Standaard: 'postgres' voor PostgreSQL, 'master' voor MSSQL. Managed SQL-servers (bijv., Azure, RDS, AlloyDB)
# blokkeren soms toegang tot deze admin-database. Stel hier een alternatieve admin-database in.
# Laat leeg om standaard te proberen en bij failure een waarschuwing te loggen.
DST_ADMIN_DB = 
# (Optioneel) Wanneer je met een OracleDB schrijft kan thick‑mode nodig zijn.
# Zet hier het pad naar de Oracle Instant Client (bijv. "C:\\oracle\\instantclient_21_18").
DST_ORACLE_CLIENT_PATH =
# (Optioneel) Als je naar een OracleDB schrijft met een TNS‑alias, zet dit op True en geef de alias
# op via 'DST_HOST' (of 'DST_DB'). Let op, als je een TNS‑alias gebruikt, worden DST_HOST en DST_PORT genegeerd
DST_ORACLE_TNS_ALIAS = False
# Optioneel (alleen voor Microsoft SQL Server via pyodbc): kies de ODBC-driver
# Mogelijke waarden: "ODBC Driver 18 for SQL Server", "ODBC Driver 17 for SQL Server", "SQL Server"
# Laat leeg om standaard (18) te gebruiken
DST_MSSQL_ODBC_DRIVER = 

[settings]
# Comma-separated van tabellen om op te halen uit de brondatabase ('database-source')
SRC_TABLES = szclient, wvbedrag, wvaanb

# Chunk size; aantal rijen dat in één keer in werkgeheugen wordt geladen
# Dit wordt gebruikt om problemen met 'larger-than-memory' data op te lossen
# Je kan het kleiner of groter maken afhankelijk van hoeveel werkgeheugen (RAM) je machine heeft
SRC_CHUNK_SIZE = 100000

# Kies de gewenste transfer modus (één van):
#  - SQLALCHEMY_DIRECT: lees via SQLAlchemy naar werkgeheugen, upload direct
#  - SQLALCHEMY_DUMP: lees via SQLAlchemy en dump naar Parquet, upload daarna Parquet
#  - CONNECTORX_DUMP: lees via ConnectorX en dump naar Parquet, upload daarna Parquet
TRANSFER_MODE = SQLALCHEMY_DIRECT

# (Optioneel) Schrijfmodus voor de staging-tabellen in de doeldatabase:
#  - replace: (default) maak de tabel opnieuw aan op de eerste write, daarna append
#  - truncate: behoud de tabelstructuur en wis eerst alle rijen, daarna append
#  - append: maak de tabel aan als die nog niet bestaat, voeg anders toe
# Geldt voor zowel de directe transfer als de Parquet upload.
WRITE_MODE = replace

# Of wachtwoord gevraagd wordt in de console i.p.v. uit te lezen uit je environment variables
# of uit je .ini-config. Als je hiervan gebruikt maakt betekent het ook dat het script
# alleen interactief gerund kan worden
ASK_PASSWORD_IN_CLI = False

# (Optioneel) Ontwikkelinstelling om slechts een subset van de data op te halen.
# Beperk het aantal rijen per tabel dat uit de brondatabase wordt gelezen (0 of leeg = geen limiet)
# Voorbeeld: alleen eerste 1000 rijen kopiëren tijdens lokale ontwikkeling
# ROW_LIMIT = 1000

# (Optioneel) Tel eerst het totaal aantal rijen per tabel met een COUNT(*). Kan performance-kosten met zich meebrengen.
# Zet op False om de telling over te slaan en meteen te gaan streamen/dumpen.
LOG_ROW_COUNT = True

# (Optioneel) Direct transfer transient error retries (alleen SQLALCHEMY_DIRECT)
# Aantal keer dat een batch-insert opnieuw geprobeerd wordt bij tijdelijke fouten
# (deadlock, timeout, disconnect). Defaults: 3; 0 om retries uit te schakelen.
DIRECT_MAX_RETRIES = 3
# Start-backoff in seconden voor retries (exponential met jitter). Default: 0.5
DIRECT_BACKOFF_BASE_SECONDS = 0.5
# Max-backoff in seconden voor retries. Default: 8.0
DIRECT_BACKOFF_MAX_SECONDS = 8.0

# Of de gedownloadde parquet-files na het uploaden naar 'database-destination' moeten
# worden verwijderd van de schijfruimte van de machine waar de Python-code draait
CLEANUP_PARQUET_FILES = True

[logging]
# Globale logging-niveau; vanaf welk type message moet gelogd worden?
# Kan zijn: DEBUG, INFO, WARNING, of ERROR
LOG_LEVEL = INFO
# Of logs in een logbestand moeten worden opgeslagen
LOG_TO_FILE = True
# Locatie van het logbestand (wordt aangemaakt indien deze nog niet bestaat)
LOG_FILE = logs/sql_to_staging.log
# Max. grootte (in bytes) van het logbestand voordat er een nieuw bestand wordt gestart (rotatie). Voorbeeld: 5.000.000 ≈ 5 MB
LOG_ROTATE_BYTES = 5000000
# Aantal oude logbestanden dat bewaard blijft bij rotatie (bijv. app.log.1 t/m app.log.N)
LOG_BACKUP_COUNT = 3
# Optioneel: eigen opmaak van logregels. Laat weg voor standaard; voorbeeld toont tijd, level, logger en bericht
# LOG_FORMAT = %(asctime)s %(levelname)-8s [%(name)s] %(message)s
